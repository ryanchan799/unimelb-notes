Models of Computation COMP30026 Lecture 6
=========================================

# Predicate Logic
- Finely express statements that deal with infinite collections of objects
- Express *relations*
- Predicate logic uses *variables* that are assumed to range over a collections of individuals e.g. lists
- Propositional letters become generalsed to *predicates*, that is, functions that map tuples to functions of `f` and `t`

#### Examples
- "No Emus Fly"
	- `∀x (Emu(x) ⇒ ¬Flies(x))`
- "There are black swans"
	- `∃x (Black(x) ∧ Swan(x))`
	- `∃y (Black(y ) ∧ Swan(y))`
- "If all push the cart, the donkey will be happy"
	- `∀x (P(x)) ⇒ H`
- "If somebody pushes, the donkey will be happy"
	- `∃x (P(x)) ⇒ H`
	- `∀x (P(x) ⇒ H)`
- `∃` means "exists"
- `∀` means "all"

#### Expressing Relations Examples
- "Tom found Rover and returned him to Anne"
	- `Found(tom, rover) ∧ Gave(tom, rover, anne)`
	- oh jeez feels like i'm doing prolog again
- "Tom found a dog and gave *it* to Anne"
	- `∃x (Dog(x) ∧ Found(tom, x) ∧ Gave(tom, x, anne))`
	- Notice how dog becomes x; we're saying x must be a dog
	- Existential Qualification ∃ means any dog, but not all dogs (otherwise Tom found every dog ever lol)
- "Jill inhabits the house that Jack built"
	- `∃x (House(x) ∧ Inhabits(jill, x) ∧ BuilderOf (jack, x))`

- "Mothers' mothers are grandmothers"
	- `∀x, y , z ((Mother(x, y ) ∧ Mother(y , z)) ⇒ Grandmother(x, z))`

## Existential and Universal Qualification
- Tom found an amount of money and gave *it* to Red Cross
- We can write it as:
	- `(Found(tom, $1) ∧ Gave(tom, $1, redcross)) ∨`
	- `(Found(tom, $2) ∧ Gave(tom, $2, redcross)) ∨`...
- Existential quantification, `∃`, is generalised ∨
	- Imply *one of all values*
- Universal quantification, `∀`, is generalised ∧
	- Imply *all values at once*

## Mechanical Inference with Predicate Logic
- You can now basically deduce whatever using predicate logic
- Given:
	- Every shark eats a tadpole.
	- All large white fish are sharks.
	- Colin is a large white fish living in deep water.
	- Any tadpole eaten by a deep water fish is miserable.
	- Therefore some tadpole is miserable.

### Vocabulary for Predicate Logic
- variables `(x, y , z, u, v , w, ... )`
- function symbols `(f , g, h, ... , +, ·, ... )`
- constants `(a, b, c, ... , 0, 1, tom, ... )`
- predicate symbols `(P, Q, R, A, B, ... , <, =)`
- connectives
- quantifiers
- parentheses
- (sometimes: f, t)
- Each function symbol comes with *arity*: a number that says how many arguments the function takes. Each predicate symbol similarly comes with an arity


wow he's literally describing prolog


## Predicate Terminology
- A *term* is a *variable* or a *constant or a construction*
> `f(t1, ..., tn)`
- Where `n > 0`, `f` is a function symbol of arity `n`, and each `ti` a term
- A constant can be considered a function of arity 0
- An **atomic formula** or *atom* is a construction
> `P(t1, ...,tn)`
- Where `n >= 0`, and `P` is a predicate symbol of arity `n`, and each `ti` is a term

We generally use the following in the below cases:

> Term <--> Individual/Object
> Atom <--> Assertion (false or true)

A *literal* is an atomic formula or its negation

#### Case Matters
- A ***predicate starts with an upper case letter; nothing else does***
- `father(ron)` is a *term*
	- "The father of ron"
- `Father(ron)` is a *formula*; it denotes a truth value
	- "Ron is a father"
- I think prolog follows this

## Predicate Logic: Syntax
- Well formed formulas are generated by the grammar
```Haskell
wff → atom
	| ¬ wff
	| wff ∧ wff
	| wff ∨ wff
	| wff ⇒ wff
	| wff ⇔ wff
	| wff ⊕ wff
	| ∀var (wff )
	| ∃var (wff )
	| ( wff )
```

### Bound and Free Variables
- A variable which is in the scope of a quantifier is *bound*
- If it is not bound, then it is *free*
- A variable may be *both free and bound*
> `∀z (P(x, y , z) ∧ ∀y (P(f (x), z, y )))`
	- The y in the first P() is different from the y after the universally symbol
- A formula with no free variable occurences is *closed*
- It is possible for scopes to have "holes"
> `∀x∃y (x < y ∧ ∃x (y < x))`
	- This is just bad writing
	- You should give the x after existential a different letter - don't consider it the same thing

### Bound Variable Renaming and Capture
- The bound variable of a quantified formula is a *placeholder*
- `∃x∀y (x < y )` means the same as `∃x∀z (x < z)`
- If a variable occurs *bound* in a cetain expression, then the meaning of that expression does not change when all bound occurences of that variable are replaced by another one.
- However, the avoid *variable capture*, we cannot change the variable bound by `∀y` to a variable in an enclosing scope
- `∃x∀y (x ≤ y )` is very different to `∃x∀x (x ≤ x)`

#### From English to Predicate Logic Examples
- Introduce symbols for predicates
- e.g. "He is a man"
	- Sentence: "He is a man"
	- Predicate: "is a man"
	- Symbol: `M()`
- e.g. "x is a man"
	- Predicate: "x is a man"
	- Symbol: `M(x)`
	- Can't be assigned a truth value
- e.g. "Kim is a man"
	- Predicate: "kim is a man"
	- Symbol: `M(kim)`
	- Can be assigned a truth value
- e.g. "Alice is taller than Kim"
	- Symbol: `T(alice, kim)`
- e.g. "Every Human is Mortal"
	- Symbol: `∀x (Human(x) ⇒ Mortal(x))`
- e.g. "Some Cat is Mortal"
	- Symbol: `∃x (Cat(x) ∧ Mortal(x))`
- Notice how it's *common to use* `⇒` with `∀` and `∧` with `∃`

##### Big Example
- Let `L(x, y)` stand for "x loves y"
- Let `I(x, y)` stand for "x is y"
- `L(bob, eva)` Bob loves Eva
- `∀x L(x, eva)` Everyone loves Eva (incl. Eva)
- `∀x (¬I(x, eva) ⇒ L(x, eva))` Eva is loved by everyone else
- `∃x (¬I(x, bob) ∧ L(x, bob))` Someone other than Bob loves Bob
- `∀x (∃y L(x, y ))` Everybody loves somebody
- `∃y (∀x L(x, y ))` Someone is loved by everybody
- `∃x (∀y L(x, y ))` Someone loves everybody

##### Big Example 2
- Translate the following statement to predicate logic:
> "Every Melburnian barracks for a footy team.""
- Use these predicates:
	- `M(x)` x is a Melburnian
	- `T(x)` x is a footy team
	- `B(x, y)` x barracks for y
- First we start with:
	- `M(x) => (T(y) ∧ B(x, y))` (i.e. Melburnian Barracks with Team)
- Then:
	- `∀x ∃y (M(x) ⇒ (T(y) ∧ B(x, y)))` (i.e. All Melburnian barracks for a footy team y)

### Predicate Order
- Word order is *important*
- “There is something which is not P”: `∃y ¬P(y )`
- “There is not something which is P” (“nothing is P”): `¬∃y P(y )`
- “All S are not P” vs “not all S are P:”
	- `∀x (S(x) ⇒ ¬P(x))` vs `¬∀x (S(x) ⇒ P(x))`
- Quantifier order is also *important*
	- `∀x∃y` is **not the same** as `∃y∀x`
	- The former says each x has a y that satisfies P(x, y ); the latter says there’s an individual y that satisfies P(x, y ) for every x
- But `∀x∀y` is **the same** as `∀y∀x` and `∃x∃y` is **the same** as `∃y∃x`

### Implicit Quantifiers
- Quantifiers are usually *implicit in English*
- Usually nouns *without determiners*
- “Humans are mortal” means “**all** humans are mortal”:
	- `∀x (Man(x) ⇒ Mortal(x))`
- “A woman is stronger than a man”:
	- `∀x∀y ((Woman(x) ∧ Man(y )) ⇒ Stronger(x, y ))`


